package models

import (
	"fmt"
	"math"

	"github.com/charmbracelet/bubbles/list"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/vague2k/laugh/parser"
)

type (
	focusedState uint // tracks which part of the view is focused
)

const (
	eventListView focusedState = iota
	descriptionView
)

var (
	// -3 is an offset to account for borders + help line
	width  = int(math.Round(float64(TermWidth())/2) - 3)
	height = TermHeight() - 3
)

// TODO: write a scrollable view that shows currently focused event description
// when this view is written, the details view should not be focusable
type GlobalModel struct {
	list    list.Model
	details tea.Model
	pager   tea.Model
	focused focusedState
	styles  GlobalStyles
	events  *[]parser.CalendarEvent
}

func NewGlobalModel(events *[]parser.CalendarEvent) GlobalModel {
	eventListModel := NewEventListModel(events)
	eventListDetailsModel := NewDetailsModel()
	pagerModel := NewPagerModel()
	styles := DefaultGlobalStyles()

	model := GlobalModel{
		list:    eventListModel,
		details: eventListDetailsModel,
		pager:   pagerModel,
		styles:  styles,
		focused: eventListView, // focused by default on program start
	}

	return model
}

func (m GlobalModel) Init() tea.Cmd {
	return nil
}

// TODO: how to handle TUI resizing?
func (m GlobalModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var updateList, updateDetails, updatePager tea.Cmd
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "q":
			return m, tea.Quit
		case "tab":
			if m.focused == eventListView {
				m.focused = descriptionView
			} else {
				m.focused = eventListView
			}
		}

		switch m.focused {
		case eventListView:
			m.list, updateList = m.list.Update(msg)
		}
	}
	pagerMsg := PagerMsg{}
	pagerMsg.Window.Height = height - 13
	pagerMsg.Window.Width = width
	pagerMsg.Focused = m.list.Items()[m.list.Index()]

	m.pager, updatePager = m.pager.Update(pagerMsg)

	item := m.list.Items()[m.list.Index()]
	m.details, updateDetails = m.details.Update(item)
	return m, tea.Batch(updateList, updateDetails, updatePager)
}

func (m GlobalModel) View() string {
	var s string
	detailsHeight := height - 85
	pagerHeight := height - 13
	if m.focused == eventListView {
		s += lipgloss.
			JoinHorizontal(
				lipgloss.Top,
				m.styles.Focused.Render(fmt.Sprintf("%4s", m.list.View())),
				lipgloss.
					JoinVertical(
						lipgloss.Top,
						m.styles.Unfocusable.Height(detailsHeight).Render(m.details.View()),
						m.styles.Unfocused.Height(pagerHeight).Render(m.pager.View())))
	} else {
		s += lipgloss.
			JoinHorizontal(
				lipgloss.Top,
				m.styles.Unfocused.Render(fmt.Sprintf("%4s", m.list.View())),
				lipgloss.
					JoinVertical(
						lipgloss.Top,
						m.styles.Unfocusable.Height(detailsHeight).Render(m.details.View()),
						m.styles.Focused.Height(pagerHeight).Render(m.pager.View())))
	}
	s += m.styles.Help.Render("\ntab: focus next â€¢ q: exit")
	return s
}

// GlobalStyles contains style definitions for the global model. these
// values are generated by DefaultGlobalStyles.
type GlobalStyles struct {
	Focused,
	Unfocused,
	Unfocusable,
	Help lipgloss.Style
}

func DefaultGlobalStyles() (s GlobalStyles) {
	s.Focused = lipgloss.NewStyle().
		Width(width).
		Height(height).
		BorderStyle(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color(TermANSIBrightYellow.String()))

	s.Unfocused = lipgloss.NewStyle().
		Width(width).
		Height(height).
		BorderStyle(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color(TermANSIBrightBlack.String()))

	s.Unfocusable = s.Unfocused

	s.Help = lipgloss.NewStyle().Foreground(lipgloss.Color(TermANSIBrightBlack.String()))

	return s
}
