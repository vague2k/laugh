package models

import (
	"fmt"
	"math"

	"github.com/charmbracelet/bubbles/list"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/vague2k/laugh/parser"
)

type (
	focusedState uint // tracks which part of the view is focused
)

const (
	eventListView focusedState = iota
	descriptionView
)

var (
	// -3 is an offset to account for borders + help line
	width  = int(math.Round(float64(TermWidth())/2) - 3)
	height = TermHeight() - 3
)

type GlobalModel struct {
	list    list.Model
	details tea.Model
	pager   tea.Model
	focused focusedState
	styles  GlobalStyles
}

func NewGlobalModel(events *[]parser.CalendarEvent) GlobalModel {
	eventListModel := NewEventListModel(events)
	eventListDetailsModel := NewDetailsModel()
	pagerModel := NewPagerModel()
	styles := DefaultGlobalStyles()

	model := GlobalModel{
		list:    eventListModel,
		details: eventListDetailsModel,
		pager:   pagerModel,
		styles:  styles,
		focused: eventListView, // focused by default on program start
	}

	return model
}

func (m GlobalModel) Init() tea.Cmd {
	return nil
}

// TODO: how to handle TUI resizing?
func (m GlobalModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd
	var cmds []tea.Cmd

	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "q":
			return m, tea.Quit
		case "tab":
			if m.focused == eventListView {
				m.focused = descriptionView
			} else {
				m.focused = eventListView
			}
		}

		switch m.focused {
		case eventListView:
			m.list, cmd = m.list.Update(msg)
			cmds = append(cmds, cmd)
		case descriptionView:
			m.pager, cmd = m.pager.Update(msg)
			cmds = append(cmds, cmd)
		}
	}

	item := m.list.Items()[m.list.Index()]

	m.pager, cmd = m.pager.Update(SendPagerMsg(width, height-13, item))
	cmds = append(cmds, cmd)

	m.details, cmd = m.details.Update(item)
	cmds = append(cmds, cmd)

	return m, tea.Batch(cmds...)
}

func (m GlobalModel) View() string {
	var s string
	detailsHeight := height - 85
	pagerHeight := height - 13
	if m.focused == eventListView {
		s += lipgloss.
			JoinHorizontal(
				lipgloss.Top,
				m.styles.Focused.Render(fmt.Sprintf("%4s", m.list.View())),
				m.styles.Gap,
				lipgloss.
					JoinVertical(
						lipgloss.Top,
						m.styles.Unfocusable.Height(detailsHeight).Render(m.details.View()),
						m.styles.Unfocused.Height(pagerHeight).Render(m.pager.View())))
	} else {
		s += lipgloss.
			JoinHorizontal(
				lipgloss.Top,
				m.styles.Unfocused.Render(fmt.Sprintf("%4s", m.list.View())),
				m.styles.Gap,
				lipgloss.
					JoinVertical(
						lipgloss.Top,
						m.styles.Unfocusable.Height(detailsHeight).Render(m.details.View()),
						m.styles.Focused.Height(pagerHeight).Render(m.pager.View())))
	}
	s += m.styles.Help.Render("\ntab: focus next â€¢ q: exit")
	return s
}

// GlobalStyles contains style definitions for the global model. these
// values are generated by DefaultGlobalStyles.
type GlobalStyles struct {
	Focused,
	Unfocused,
	Unfocusable,
	Help lipgloss.Style
	Gap string
}

func DefaultGlobalStyles() (s GlobalStyles) {
	s.Focused = lipgloss.NewStyle().
		Width(width).
		Height(height).
		BorderStyle(lipgloss.NormalBorder()).
		BorderForeground(lipgloss.Color(TermANSIBrightYellow.String()))

	s.Unfocused = lipgloss.NewStyle().
		Width(width).
		Height(height).
		BorderStyle(lipgloss.NormalBorder()).
		BorderForeground(lipgloss.Color(TermANSIBrightBlack.String()))

	s.Unfocusable = s.Unfocused

	s.Gap = lipgloss.NewStyle().Render(" ")

	s.Help = lipgloss.NewStyle().Foreground(lipgloss.Color(TermANSIBrightBlack.String()))

	return s
}
