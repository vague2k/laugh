package main

import (
	"fmt"
	"math"

	"github.com/charmbracelet/bubbles/list"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

type focusedState uint // tracks which part of the view is focused
const (
	eventListView focusedState = iota
	eventListDetailsView
)

var (
	// -3 is an offset to account for borders + help line
	width  = int(math.Round(float64(TermWidth())/2) - 3)
	height = TermHeight() - 3
)

// TODO: write a scrollable view that shows currently focused event description
// when this view is written, the details view should not be focusable
type GlobalModel struct {
	list    list.Model
	details tea.Model
	focused focusedState
	styles  GlobalStyles
	events  *[]CalendarEvent
}

func NewGlobalModel(events *[]CalendarEvent) GlobalModel {
	eventListModel := NewEventListModel(events)
	eventListDetailsModel := NewDetailsModel()
	styles := DefaultGlobalStyles()

	model := GlobalModel{
		list:    eventListModel,
		details: eventListDetailsModel,
		styles:  styles,
		focused: eventListView, // focused by default on program start
	}

	return model
}

func (m GlobalModel) Init() tea.Cmd {
	return nil
}

// TODO: how to handle TUI resizing?
func (m GlobalModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var updateList, updateDetails tea.Cmd
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "q":
			return m, tea.Quit
		case "tab":
			if m.focused == eventListView {
				m.focused = eventListDetailsView
			} else {
				m.focused = eventListView
			}
		}

		switch m.focused {
		case eventListView:
			m.list, updateList = m.list.Update(msg)
		}
	}

	item := m.list.Items()[m.list.Index()]
	m.details, updateDetails = m.details.Update(item)
	return m, tea.Batch(updateList, updateDetails)
}

func (m GlobalModel) View() string {
	var s string
	if m.focused == eventListView {
		s += lipgloss.
			JoinHorizontal(
				lipgloss.Top,
				m.styles.Focused.Render(fmt.Sprintf("%4s", m.list.View())),
				m.styles.Unfocused.Render(m.details.View()))
	} else {
		s += lipgloss.
			JoinHorizontal(lipgloss.Top,
				m.styles.Unfocused.Render(fmt.Sprintf("%4s", m.list.View())),
				m.styles.Focused.Render(m.details.View()))
	}
	s += m.styles.Help.Render("\ntab: focus next â€¢ q: exit")
	return s
}

// GlobalStyles contains style definitions for the global model. these
// values are generated by DefaultGlobalStyles.
type GlobalStyles struct {
	Focused,
	Unfocused,
	Help lipgloss.Style
}

func DefaultGlobalStyles() (s GlobalStyles) {
	s.Focused = lipgloss.NewStyle().
		Width(width).
		Height(height).
		BorderStyle(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color(termANSIBrightYellow.String()))

	s.Unfocused = lipgloss.NewStyle().
		Width(width).
		Height(height).
		BorderStyle(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color(termANSIBrightBlack.String()))

	s.Help = lipgloss.NewStyle().Foreground(lipgloss.Color(termANSIBrightBlack.String()))

	return s
}
